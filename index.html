<script src="osf-marked.js"></script>
<script src="node_modules/ace-builds/src/ace.js"></script>
<script src="osf-language-tools.js"></script>
<script src="node_modules/jquery/dist/jquery.min.js"></script>
<!--Uncomment below for highlighting-->
<!--<script src="node_modules/highlight/lib/vendor/highlight.js/highlight.pack.js"></script>-->
<!--<script>hljs.initHighlightingOnLoad();</script>-->

<style type="text/css" media="screen">
    #editor {
        position: relative;
        height: 300px;
        width: 600px;
    }
</style>


<div id="editor">
Markdown Test
============
 > There is a trailing space in the line above. This affects Markdown only.
 > Blockquotes require two newlines in Marked.

## First Section ##
Lorem ipsum blah blah I **don't** remember the text, and I *don't* know latin.

<!--[[user:nf3cv]]-->

### Youtube Subsection ###

It's commented out for speed, but I swear it works!
<!--[[youtube:lq4LBjhbB4U]]-->

## Second Section ##

There is a trailing space ~~in the line~~ above. This affects showdown only.
### Ordered List ###

1. Foo
1. Foo
1. Foo

### Unordered List ###

* Foo
- Foo
+ Foo

### My Little Table ###

Foo                 | Bar           | State
:------------------ | :-----------: | -----:
`Code aligned left` | Broken        | Really, really happy
Code                | In the center | Happy
Code                | Broken        | Happy

### Image Below ###
Commented out for speed.
<!--![puddle](https://raw.githubusercontent.com/rliebz/Puddle/master/Content/PC/stand.png "Mouseover Text")-->
And a corresponding link: https://github.com/rliebz/puddle
### Python Code Block ###
```python
s = "Python string"
if indent_exists_below:
    print s
```
</div>

<button onclick="renderCode()">Render</button>

<div id="rendered"></div>


<script>

    var langTools = ace.require("ace/ext/language_tools");
    var editor = ace.edit("editor");
    editor.getSession().setMode("ace/mode/markdown");

    function renderCode() {
        document.getElementById("rendered").innerHTML = marked(editor.getSession().doc.getValue());
    }

    // Settings
    editor.getSession().setUseSoftTabs(true);   // Replace tabs with spaces
    editor.renderer.setShowGutter(false);       // Hides line numbers

    // Max caption width for autocomplete
    var MAX_CAPTION = 28;

    function parseUsers(data) {
        console.timeEnd('Ajax');
        var completions = [];
        var users = data.users;

        // Make user objects
        for (var i in users) {
            var user = users[i];
            var shortName = (user.fullname.length > MAX_CAPTION) ?
                    user.fullname.substring(0, MAX_CAPTION - 3) + '...' : user.fullname;
            completions.push({
                caption: ' ' + shortName,
                value: '@' + user.fullname + ' ' + user.id,
                meta: user.id,
                uid: user.id,
                markdown: '@[' + user.fullname + '](' + user.id + ') '
            })
        }
        return completions;
    }

    function parseNodes(data) {
        console.timeEnd('Ajax');
        var completions = [];
        for (var i in data.results) {
            var p = data.results[i];
            if (p.hasOwnProperty('contributors')) {
                var uid = p.url.slice(1, -1);
                var shortTitle = (p.title.length > MAX_CAPTION) ?
                        p.title.substring(0, MAX_CAPTION - 3) + '...' :  p.title;
                console.log('uid', uid);
                completions.push({
                    caption: '  ' + shortTitle,
                    value: '@@' + p.title + ' ' + uid,
                    meta: uid,
                    uid: uid,
                    markdown: '@[' + p.title + '](' + uid + ') '
                })
            }
        }
        return completions;
    }

    // TODO: Get contributor list with AJAX using project ID
    var contributorList = [{
        caption: ' Brian Nosek',
        value: '@Brian Nosek brian',
        meta: 'brian',
        uid: 'brian',
        markdown: '@[Brian Nosek](brian)'
    },{
        caption: ' Josh Carp',
        value: '@Josh Carp jmcar',
        meta: 'jmcar',
        uid: 'jmcar',
        markdown: '@[Josh Carp](jmcar)'
    },{
        caption: ' Chris Seto',
        value: '@Chris Seto chris',
        meta: 'chris',
        uid: 'chris',
        markdown: '@[Chris Seto](chris)'
    }];

    var nodeList = [{
        caption: '  Analysis of different mar...',
        value: '@@Analysis of different markdown parsers and textual autocompletion in javascript uid12',
        meta: 'uid12',
        uid: 'uid12',
        markdown: '@[Analysis of different markdown parsers and textual autocompletion in javascript](uid12)'
    },{
        caption: '  Markdown analysis data',
        value: '@@Markdown analysis data uid13',
        meta: 'uid13',
        uid: 'uid13',
        markdown: '@[Markdown analysis data](uid13)'
    }];

    editor.resolvedNames = {"@": true};
    var nameCompletions = contributorList;
    var nameTrie = {};
    nameTrie['@'] = {};

    editor.resolvedNodes = {"@@": true};
    var nodeCompletions = nodeList;
    var nodeTrie = {};
    nodeTrie['@'] = {'@': {}};


    function uniquify(array) {
        var output = array.concat();
        for(var i = 0; i < output.length; i++) {
            for(var j = i+1; j < output.length; j++) {
                if(output[i].uid === output[j].uid)
                    output.splice(j--, 1);
            }
        }

        return output;
    }

    function prefixFailed(rootObj, str) {
        // Base case: Prefix may yield results
        if (str.length < 1)
            return false;

        var index = str[0];

        if (rootObj[index] === false)
            return true;

        // Recurse down trie
        if (!(index in rootObj))
            rootObj[index] = {};
        return prefixFailed(rootObj[index], str.substring(1));
    }

    function setTrieFalse(rootObj, str) {
        // Base case: Set prefix value to false
        if (str.length < 2) {
            rootObj[str] = false;
            return true;
        }

        var index = str[0];

        // Prefix returned no results. This case will generally be avoided
        // but can occur as a result of asynchronous requests
        if (rootObj[index] === false){
            return false;
        }

        // Recurse down trie
        if (!(index in rootObj))
            rootObj[index] = {};
        return setTrieFalse(rootObj[index], str.substring(1));
    }

    var queryTimeout;
    var numRequests = 0;
    function setCompleter() {
        var queryCompleter = {
            getCompletions: function(editor, session, pos, prefix, callback) {

                if (prefix.substring(0, 2) === '@@') {
                    editor.searchMode = 'node';

                    console.log('beginning prefix', prefix);

                    if (prefix in editor.resolvedNodes || prefixFailed(nodeTrie, prefix)) {
                        console.log('prefix already resolved', prefix);
                        editor.resolvedNodes[prefix] = true;
                        callback(null, nodeCompletions);
                        return;
                    }

                    // TODO: Fix endpoint
                    var url = 'http://localhost:5000/api/v1/search/?q=' + prefix.substring(2);

                    clearTimeout(queryTimeout);
                    queryTimeout = setTimeout(function () {
                        numRequests++;
                        console.time('Ajax');
                        console.log('getting node', prefix);
                        $.ajax({
                            url: url,
                            dataType: 'json',
                            cache: false
                        }).then(parseNodes).then(function (completions) {
                            // TODO: Don't parse users, parse nodes

                            // Only act on the most recent request
                            if (--numRequests > 0)
                                return;

                            if (completions.length < 10) // We won't get more results
                                setTrieFalse(nodeTrie, prefix);
                            editor.resolvedNodes[prefix] = true;
                            nodeCompletions = uniquify(nodeCompletions.concat(completions));
                            console.log('-- JSON RETRIEVED:', prefix, '--\n', completions);
                            callback(null, nodeCompletions);
                        });
                    }, 400);
                }

                else {
                    editor.searchMode = 'name'

                    if (prefix in editor.resolvedNames || prefixFailed(nameTrie, prefix)) {
                        editor.resolvedNames[prefix] = true;
                        callback(null, nameCompletions);
                        return;
                    }

                    var url = 'http://localhost:5000/api/v1/user/search/?query=' + prefix.substring(1);

                    clearTimeout(queryTimeout);
                    queryTimeout = setTimeout(function () {
                        numRequests++;
                        console.time('Ajax');
                        console.log('getting user', prefix);
                        $.ajax({
                            url: url,
                            dataType: 'json',
                            cache: false
                        }).then(parseUsers).then(function (completions) {

                            // Only act on the most recent request
                            if (--numRequests > 0)
                                return;

                            if (completions.length < 10) // We won't get more results
                                setTrieFalse(nameTrie, prefix);
                            editor.resolvedNames[prefix] = true;
                            nameCompletions = uniquify(nameCompletions.concat(completions));
                            console.log('-- JSON RETRIEVED:', prefix, '--\n', completions);
                            console.log('-- Name Completions --\n', nameCompletions);
                            callback(null, nameCompletions);
                        });
                    }, 400);
                }
            }
        };

        editor.setOptions({enableCustomAutocompletion: [queryCompleter]});
    }

    var renderTimeout;
    function onChange() {
        clearTimeout(renderTimeout);
        renderTimeout = setTimeout(renderCode, 3000);
    }

    // Initialize list
    setCompleter();
    editor.getSession().on('change', onChange);   // Render code on change

    renderCode();

</script>